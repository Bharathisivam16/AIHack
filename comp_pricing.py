"""
Competitive Pricing Streamlit App (single-file)

Features:
- Sample data for three retailers: THB, SuperBuy, MartD
- Streamlit frontend: product name input + choose your retailer
- Computes competitive prices, lowest/second-lowest, gaps
- Recommends a competitive price and shows explanation generated by GPT-4 (if OPENAI_API_KEY provided)

Run:
1. Install requirements: pip install streamlit pandas openai
2. Set your OpenAI API key: export OPENAI_API_KEY="sk-..." (or set in your environment)
3. Run the app: streamlit run competitive_pricing_app.py

Notes:
- This is a sample/demo. Tune the pricing logic and risk controls before using in production.
"""

import os
import math
import pandas as pd
import streamlit as st

# OpenAI (newer python client) - fallback if not available
try:
    from openai import OpenAI
    openai_available = True
except Exception:
    openai_available = False

# -------------------- Sample data --------------------
# For a real app you'd load this from a database or CSV.
SAMPLE_DATA = [
    {"product": "Wireless Mouse X100", "retailer": "THB", "price": 499.0},
    {"product": "Wireless Mouse X100", "retailer": "SuperBuy", "price": 479.0},
    {"product": "Wireless Mouse X100", "retailer": "MartD", "price": 489.0},

    {"product": "USB-C Charger 30W", "retailer": "THB", "price": 799.0},
    {"product": "USB-C Charger 30W", "retailer": "SuperBuy", "price": 749.0},
    {"product": "USB-C Charger 30W", "retailer": "MartD", "price": 769.0},

    {"product": "Noise Cancelling Headphones Z", "retailer": "THB", "price": 3499.0},
    {"product": "Noise Cancelling Headphones Z", "retailer": "SuperBuy", "price": 3299.0},
    {"product": "Noise Cancelling Headphones Z", "retailer": "MartD", "price": 3399.0},

    {"product": "Portable SSD 1TB", "retailer": "THB", "price": 6499.0},
    {"product": "Portable SSD 1TB", "retailer": "SuperBuy", "price": 6299.0},
    {"product": "Portable SSD 1TB", "retailer": "MartD", "price": 6399.0},
]

DF = pd.DataFrame(SAMPLE_DATA)
RETAILERS = sorted(DF['retailer'].unique())

# -------------------- Pricing logic --------------------

def compute_competitive_recommendation(product_rows, your_retailer, min_margin_pct=0.02):
    """
    product_rows: DataFrame with columns ['retailer','price'] for the product
    your_retailer: string name of the retailer making the decision
    returns: dict with price table, lowest, recommended price and rationale fields
    """
    table = product_rows.copy().sort_values('price')
    lowest_row = table.iloc[0]
    lowest_price = float(lowest_row['price'])
    lowest_retailer = lowest_row['retailer']

    # second lowest (if exists)
    second_lowest_price = None
    if len(table) > 1:
        second_lowest_price = float(table.iloc[1]['price'])

    your_row = table[table['retailer'] == your_retailer]
    your_price = float(your_row['price'].iloc[0]) if not your_row.empty else None

    # Simple recommendation strategy:
    # - If you're not the lowest: propose to undercut the lowest by a small epsilon but maintain min margin
    # - If you are already the lowest: suggest to keep price or increase slightly toward second-lowest

    epsilon = 1.0  # currency units to undercut by
    recommended_price = None
    strategy = ""

    if your_price is None:
        # If user retailer has no listing, recommend a market-entry price: slightly below current lowest
        recommended_price = max( max(0.0, lowest_price - epsilon), 0.0 )
        strategy = f"Your retailer ({your_retailer}) has no current listing for this product. Recommended market-entry price is lowest_price - {epsilon}"
    else:
        if your_price > lowest_price:
            candidate = round(max(lowest_price - epsilon, 0.0), 2)
            # ensure candidate is not below cost-like floor (approx using min_margin_pct)
            floor = round(your_price * (1 - 0.5 * min_margin_pct), 2)  # naive floor heuristic
            recommended_price = max(candidate, floor)
            strategy = f"Undercut current lowest ({lowest_retailer}) by {epsilon} where possible, but don't go below a safety floor."
        elif math.isclose(your_price, lowest_price, rel_tol=1e-9) or your_price == lowest_price:
            if second_lowest_price is not None:
                # suggest small increase toward second lowest to improve margin if gap exists
                gap = second_lowest_price - lowest_price
                bump = round(min(gap * 0.25, 5.0), 2)
                recommended_price = round(min(your_price + bump, second_lowest_price - 0.01), 2)
                strategy = "You're the current lowest — consider small, cautious pricing changes to improve margin while staying competitive."
            else:
                recommended_price = your_price
                strategy = "You're the only seller listed — maintain price and monitor market."
        else:
            # your_price < lowest_price (you are already lower but maybe by too much)
            recommended_price = your_price
            strategy = "You are already priced below other retailers. Consider whether margin is acceptable."

    return {
        'table': table.reset_index(drop=True),
        'lowest_price': lowest_price,
        'lowest_retailer': lowest_retailer,
        'second_lowest_price': second_lowest_price,
        'your_price': your_price,
        'recommended_price': float(recommended_price) if recommended_price is not None else None,
        'strategy_text': strategy,
    }

# -------------------- GPT-4 explanation helper --------------------

def generate_gpt4_explanation(openai_client, product_name, price_table, rec):
    """Ask GPT-4 to explain the price recommendation in plain language."""
    # Build a concise prompt
    rows_text = "\n".join([f"- {r['retailer']}: {r['price']}" for _, r in price_table.iterrows()])

    prompt = (
        f"You are a pricing analyst.
Provide a short (3-5 sentence) explanation and bullet-point action steps for the following pricing situation for product '{product_name}':\n"
        f"Current prices:\n{rows_text}\n"
        f"Recommended price: {rec['recommended_price']} (for retailer {rec.get('your_price')}).\n"
        f"Explain the rationale, risks, and two quick action steps the retailer should take next. Keep it concise and business-like."
    )

    try:
        response = openai_client.responses.create(
            model="gpt-4",
            input=prompt,
        )
        # New responses API returns output_text convenience for simple cases
        text = getattr(response, 'output_text', None)
        if text is None:
            # fallback parsing
            choices = response.output if hasattr(response, 'output') else None
            if choices and isinstance(choices, list) and len(choices) > 0:
                text = choices[0].get('content', {}).get('text', '')
            else:
                text = str(response)
        return text
    except Exception as e:
        return f"(GPT-4 call failed: {e})"

# -------------------- Streamlit UI --------------------

st.set_page_config(page_title="Competitive Pricing App", layout="centered")
st.title("Competitive Pricing Assistant — THB / SuperBuy / MartD")
st.markdown("Enter a product name (example: 'Wireless Mouse X100') and select your retailer. The app will show competitor prices and a recommended competitive price.")

product_input = st.text_input("Product name", value="Wireless Mouse X100")
user_retailer = st.selectbox("Your retailer", options=RETAILERS)

if st.button("Get competitive prices"):
    # simple case-insensitive contains match for product
    mask = DF['product'].str.lower().str.contains(product_input.strip().lower())
    if not mask.any():
        st.warning("No matching product found in sample data. Try a different name or use one of the sample products from the dropdown.")
        st.info("Sample products: \n" + "\n".join(sorted(DF['product'].unique())))
    else:
        product_rows = DF[mask][['retailer','price']]
        rec = compute_competitive_recommendation(product_rows, user_retailer)

        st.subheader("Price table")
        st.table(rec['table'].rename(columns={'price':'Price'}))

        st.markdown(f"**Lowest price:** {rec['lowest_price']} (by {rec['lowest_retailer']})")
        if rec['second_lowest_price'] is not None:
            st.markdown(f"**Second lowest:** {rec['second_lowest_price']}")

        st.markdown(f"**Your current price:** {rec['your_price']}")
        st.markdown(f"### Recommended competitive price: {rec['recommended_price']}")
        st.write(rec['strategy_text'])

        # Attempt GPT-4 explanation if available and API key present
        api_key = os.environ.get('OPENAI_API_KEY')
        if openai_available and api_key:
            try:
                client = OpenAI(api_key=api_key)
                with st.spinner("Generating explanation from GPT-4..."):
                    explanation = generate_gpt4_explanation(client, product_input, rec['table'].to_dict('records') if False else rec['table'], rec)
                st.subheader("GPT-4 Explanation / Rationale")
                st.write(explanation)
            except Exception as e:
                st.error(f"Could not call OpenAI API: {e}")
        else:
            st.info("GPT-4 explanation skipped — set OPENAI_API_KEY in your environment and install the OpenAI Python client to enable.")

        # Simple CSV export
        csv = rec['table'].to_csv(index=False)
        st.download_button("Download price table (CSV)", data=csv, file_name=f"prices_{product_input.replace(' ','_')}.csv")

# Footer
st.markdown("---")
st.caption("This demo app uses a simple heuristic pricing strategy. Do not use as financial/legal advice.")
